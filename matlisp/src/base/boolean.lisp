(in-package #:matlisp)

;;Define boolean tensor
(eval-every
  (tensor 'boolean)
  (deft/method (t/store-allocator #'(lambda (x) (eql (field-type x) 'boolean))) (type simple-vector-store-mixin) (size &rest initargs)
    `(t/store-allocator ,(tensor 'bit) ,size ,@initargs))
  (deft/method (t/store-type #'(lambda (x) (member (field-type x) '(bit boolean)))) (type simple-vector-store-mixin) (&optional (size '*))
    `(simple-bit-vector ,size))

  (deft/method (t/store-ref #'(lambda (x) (eql (field-type x) 'boolean))) (type simple-vector-store-mixin) (store &rest idx)
    (with-gensyms (out)
      `(let-typed ((,out (t/store-ref ,(tensor 'bit) ,store ,@idx) :type bit))
	 (the boolean (case ,out (1 t))))))
  (deft/method (t/store-set #'(lambda (x) (eql (field-type x) 'boolean))) (type simple-vector-store-mixin) (value store &rest idx)
    `(setf (t/store-ref ,(tensor 'bit) ,store ,@idx) (the bit (if ,value 1 0)))))
;;
(closer-mop:defgeneric ge= (a b)
  (:method ((a tensor) (b tensor))
    (assert (lvec-eq (dimensions a) (dimensions b)) nil 'tensor-dimension-mismatch))
  (:generic-function-class tensor-method-generator))
(define-tensor-method ge= (a (b dense-tensor :x))
  `(let ((a (t/coerce ,(field-type (cl :x)) a))
	 (ret (zeros (dimensions b) (tensor 'boolean))))
     (dorefs (idx (dimensions b))
	     ((ref.b b :type ,(cl :x))
	      (ref.r ret :type ,(tensor 'boolean)))
	     (setf ref.r (t/f= ,(field-type (cl :x)) a ref.b)))
     ret))
(define-tensor-method ge= ((a dense-tensor :x) (b dense-tensor :x))
  `(let ((ret (zeros (dimensions a) (tensor 'boolean))))
     (dorefs (idx (dimensions a))
	     ((ref.a a :type ,(cl :x))
	      (ref.b b :type ,(cl :x))
	      (ref.r ret :type ,(tensor 'boolean)))
	     (setf ref.r (t/f= ,(field-type (cl :x)) ref.a ref.b)))
     ret))
;;
(closer-mop:defgeneric ga= (a b)
  (:method ((a tensor) (b tensor))
    (assert (lvec-eq (dimensions a) (dimensions b)) nil 'tensor-dimension-mismatch))
  (:generic-function-class tensor-method-generator))
(define-tensor-method ga= (a (b dense-tensor :x))
  `(let ((a (t/coerce ,(field-type (cl :x)) a))
	 (ret t))
     (with-memoization ()
       (iter (for-mod idx from 0 below (dimensions b) with-iterator ((:stride ((of-b (strides b) (head b))))))
	     (unless (t/f= ,(field-type (cl :x)) a (t/store-ref ,(cl :x) (memoizing (store b) :type ,(store-type (cl :x)) :global t) of-b))
	       (setf ret nil)
	       (return))))
     ret))
(define-tensor-method ga= ((a dense-tensor :x) (b dense-tensor :x))
  `(let ((ret t))
     (with-memoization ()
       (iter (for-mod idx from 0 below (dimensions b) with-iterator ((:stride ((of-a (strides a) (head a))
									       (of-b (strides b) (head b))))))
	     (unless (t/f= ,(field-type (cl :x))
			   (t/store-ref ,(cl :x) (memoizing (store a) :type ,(store-type (cl :x)) :global t) of-a)
			   (t/store-ref ,(cl :x) (memoizing (store b) :type ,(store-type (cl :x)) :global t) of-b))
	       (setf ret nil)
	       (return))))
     ret))
(closer-mop:defmethod ga= ((a null) (b #.(tensor 'boolean)))
  (declare (ignore a))
  (let ((ret t))
    (with-memoization ()
      (iter (for-mod idx from 0 below (dimensions b) with-iterator ((:stride ((of-b (strides b) (head b))))))
	    (unless (t/store-ref #.(tensor 'boolean) (memoizing (store b) :type #.(store-type (tensor 'boolean)) :global t) of-b)
	      (setf ret nil)
	      (return))))
    ret))
;;
(closer-mop:defgeneric go= (a b)
  (:method ((a tensor) (b tensor))
    (assert (lvec-eq (dimensions a) (dimensions b)) nil 'tensor-dimension-mismatch))
  (:generic-function-class tensor-method-generator))
(define-tensor-method go= (a (b dense-tensor :x))
  `(let ((a (t/coerce ,(field-type (cl :x)) a))
	 (ret nil))
     (with-memoization ()
       (iter (for-mod idx from 0 below (dimensions b) with-iterator ((:stride ((of-b (strides b) (head b))))))
	     (when (t/f= ,(field-type (cl :x)) a (t/store-ref ,(cl :x) (memoizing (store b) :type ,(store-type (cl :x)) :global t) of-b))
	       (setf ret t)
	       (return))))
     ret))
(define-tensor-method go= ((a dense-tensor :x) (b dense-tensor :x))
  `(let ((ret nil))
     (with-memoization ()
       (iter (for-mod idx from 0 below (dimensions b) with-iterator ((:stride ((of-a (strides a) (head a))
									       (of-b (strides b) (head b))))))
	     (when (t/f= ,(field-type (cl :x))
			 (t/store-ref ,(cl :x) (memoizing (store a) :type ,(store-type (cl :x)) :global t) of-a)
			 (t/store-ref ,(cl :x) (memoizing (store b) :type ,(store-type (cl :x)) :global t) of-b))
	       (setf ret t)
	       (return))))
     ret))
(closer-mop:defmethod go= ((a null) (b #.(tensor 'boolean)))
  (declare (ignore a))
  (let ((ret nil))
    (with-memoization ()
      (iter (for-mod idx from 0 below (dimensions b) with-iterator ((:stride ((of-b (strides b) (head b))))))
	    (when (t/store-ref #.(tensor 'boolean) (memoizing (store b) :type #.(store-type (tensor 'boolean)) :global t) of-b)
	      (setf ret t)
	      (return))))
    ret))
;; (zeros 2 (tensor 'boolean))
;; (go= (ones 2) #d[1, 0])
